from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional
import re

app = FastAPI()

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:3001"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ChatRequest(BaseModel):
    message: str

class ChatResponse(BaseModel):
    message: str
    link: Optional[str]
    category: Optional[str]

def detect_intent(user_message: str) -> tuple[str, Optional[str]]:
    """
    Detect user intent and return appropriate response with link
    """
    message_lower = user_message.lower()
    
    # Test cases keywords
    testcase_keywords = [
        "test case", "testcase", "create test", "generate test", 
        "test automation", "automated test", "test scenario"
    ]
    
    # Banking products keywords
    banking_keywords = [
        "cif", "loan", "account", "ccod", "deposit", 
        "create account", "loan account", "banking account",
        "ccod deposit", "deposit account"
    ]
    
    # QNA application keywords
    qna_keywords = [
        "qna", "q&a", "question", "answer", "faq",
        "knowledge base", "qa application", "q&a application"
    ]
    
    # Check for test cases
    if any(keyword in message_lower for keyword in testcase_keywords):
        return "test_cases", "https://abc.com"
    
    # Check for banking products
    if any(keyword in message_lower for keyword in banking_keywords):
        return "banking_products", "https://bank-portal.com"
    
    # Check for QNA
    if any(keyword in message_lower for keyword in qna_keywords):
        return "qna_application", "https://qna-app.com"
    
    return "unknown", None

@app.post("/chat")
async def chat(request: ChatRequest):
    """
    Process user message and return response with link if applicable
    """
    user_message = request.message.strip()
    
    if not user_message:
        return ChatResponse(
            message="Please provide a message",
            link=None,
            category=None
        )
    
    category, link = detect_intent(user_message)
    
    # Generate appropriate response based on category
    if category == "test_cases":
        response_msg = "I can help you with test case creation and generation. Redirecting you to the test management portal."
    elif category == "banking_products":
        response_msg = "I'll help you with CIF, Loan accounts, CCOD deposits, or other banking products. Redirecting you to the banking portal."
    elif category == "qna_application":
        response_msg = "I'll assist you with our Q&A application. Redirecting you to the QNA platform."
    else:
        response_msg = "I'm not sure which service you need. Please ask about: test cases, banking products (CIF/Loan/CCOD/Deposit), or Q&A application."
    
    return ChatResponse(
        message=response_msg,
        link=link,
        category=category
    )

@app.get("/health")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)




'use client';

import { useState, useRef, useEffect } from 'react';

export default function ChatBot() {
  const [messages, setMessages] = useState([
    {
      id: 1,
      text: 'Hi! I can help you with:\n• Test case creation and generation\n• Banking products (CIF, Loan, CCOD, Deposits)\n• Q&A application\n\nWhat do you need help with?',
      sender: 'bot',
      link: null,
    },
  ]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const sendMessage = async () => {
    if (!input.trim()) return;

    const userMessage = input;
    setInput('');

    // Add user message to chat
    const newUserMessage = {
      id: Date.now(),
      text: userMessage,
      sender: 'user',
      link: null,
    };
    setMessages((prev) => [...prev, newUserMessage]);
    setLoading(true);

    try {
      const response = await fetch('http://localhost:8000/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: userMessage }),
      });

      const data = await response.json();

      const botMessage = {
        id: Date.now() + 1,
        text: data.message,
        sender: 'bot',
        link: data.link,
        category: data.category,
      };

      setMessages((prev) => [...prev, botMessage]);
    } catch (error) {
      const errorMessage = {
        id: Date.now() + 1,
        text: 'Sorry, there was an error connecting to the server.',
        sender: 'bot',
        link: null,
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div style={styles.container}>
      <div style={styles.chatHeader}>
        <h1 style={styles.title}>Service Assistant</h1>
        <p style={styles.subtitle}>Get quick access to your needed services</p>
      </div>

      <div style={styles.messagesContainer}>
        {messages.map((msg) => (
          <div key={msg.id} style={styles.messageWrapper}>
            <div
              style={{
                ...styles.message,
                ...(msg.sender === 'user'
                  ? styles.userMessage
                  : styles.botMessage),
              }}
            >
              <p style={styles.messageText}>{msg.text}</p>
              {msg.link && (
                <a
                  href={msg.link}
                  target="_blank"
                  rel="noopener noreferrer"
                  style={styles.link}
                >
                  Open Portal →
                </a>
              )}
            </div>
          </div>
        ))}
        {loading && (
          <div style={styles.messageWrapper}>
            <div style={styles.botMessage}>
              <p style={styles.loadingText}>Thinking...</p>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <div style={styles.inputContainer}>
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder="Type your request here..."
          style={styles.input}
          disabled={loading}
        />
        <button
          onClick={sendMessage}
          disabled={loading || !input.trim()}
          style={{
            ...styles.button,
            ...(loading || !input.trim()
              ? styles.buttonDisabled
              : styles.buttonActive),
          }}
        >
          Send
        </button>
      </div>
    </div>
  );
}

const styles = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    height: '100vh',
    fontFamily: '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif',
    backgroundColor: '#f5f5f5',
  },
  chatHeader: {
    backgroundColor: '#2c3e50',
    color: 'white',
    padding: '20px',
    textAlign: 'center',
    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.1)',
  },
  title: {
    margin: '0',
    fontSize: '24px',
    fontWeight: '600',
  },
  subtitle: {
    margin: '5px 0 0 0',
    fontSize: '14px',
    opacity: '0.8',
  },
  messagesContainer: {
    flex: 1,
    overflowY: 'auto',
    padding: '20px',
    display: 'flex',
    flexDirection: 'column',
    gap: '12px',
  },
  messageWrapper: {
    display: 'flex',
    marginBottom: '8px',
  },
  message: {
    maxWidth: '70%',
    padding: '12px 16px',
    borderRadius: '8px',
    wordWrap: 'break-word',
    whiteSpace: 'pre-wrap',
  },
  userMessage: {
    alignSelf: 'flex-end',
    backgroundColor: '#3498db',
    color: 'white',
    marginLeft: 'auto',
    borderBottomRightRadius: '2px',
  },
  botMessage: {
    alignSelf: 'flex-start',
    backgroundColor: 'white',
    color: '#333',
    border: '1px solid #ddd',
    borderBottomLeftRadius: '2px',
  },
  messageText: {
    margin: '0 0 8px 0',
    fontSize: '14px',
    lineHeight: '1.4',
  },
  link: {
    display: 'inline-block',
    backgroundColor: '#27ae60',
    color: 'white',
    padding: '8px 12px',
    borderRadius: '4px',
    textDecoration: 'none',
    fontSize: '13px',
    fontWeight: '500',
    marginTop: '8px',
    cursor: 'pointer',
    transition: 'background-color 0.2s',
  },
  loadingText: {
    margin: '0',
    fontSize: '14px',
    fontStyle: 'italic',
    color: '#666',
  },
  inputContainer: {
    display: 'flex',
    gap: '10px',
    padding: '16px',
    backgroundColor: 'white',
    borderTop: '1px solid #ddd',
    boxShadow: '0 -2px 5px rgba(0, 0, 0, 0.05)',
  },
  input: {
    flex: 1,
    padding: '12px',
    border: '1px solid #ddd',
    borderRadius: '4px',
    fontSize: '14px',
    fontFamily: 'inherit',
    resize: 'none',
    maxHeight: '100px',
  },
  button: {
    padding: '12px 24px',
    borderRadius: '4px',
    border: 'none',
    fontWeight: '500',
    cursor: 'pointer',
    fontSize: '14px',
    transition: 'all 0.2s',
  },
  buttonActive: {
    backgroundColor: '#3498db',
    color: 'white',
  },
  buttonDisabled: {
    backgroundColor: '#bdc3c7',
    color: '#7f8c8d',
    cursor: 'not-allowed',
  },
};





with llm
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional
import anthropic
import json

app = FastAPI()

# Initialize Anthropic client
client = anthropic.Anthropic()

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:3001"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ChatRequest(BaseModel):
    message: str

class ChatResponse(BaseModel):
    message: str
    link: Optional[str]
    category: Optional[str]

def detect_intent_with_llm(user_message: str) -> tuple[str, Optional[str], str]:
    """
    Use Claude LLM to detect user intent and generate response
    Returns: (category, link, response_message)
    """
    
    system_prompt = """You are a helpful assistant that routes users to the right service portal.

Analyze the user's message and determine which category they belong to:

1. "test_cases" - User wants to create or generate test cases
   Link: https://abc.com
   
2. "banking_products" - User wants to work with CIF, Loan accounts, CCOD deposits, or other banking products
   Link: https://bank-portal.com
   
3. "qna_application" - User wants to use the Q&A/FAQ application
   Link: https://qna-app.com
   
4. "unknown" - User query doesn't match any category
   Link: null

Respond in JSON format ONLY with these exact fields:
{
  "category": "test_cases" | "banking_products" | "qna_application" | "unknown",
  "link": "https://..." or null,
  "response": "Your helpful response message here"
}

Important:
- Be conversational and helpful
- If the category is not unknown, include the portal link in your response
- Keep responses concise (1-2 sentences)
- Include encouragement and next steps
"""
    
    try:
        message = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=500,
            system=system_prompt,
            messages=[
                {
                    "role": "user",
                    "content": user_message
                }
            ]
        )
        
        response_text = message.content[0].text
        
        # Parse JSON response
        result = json.loads(response_text)
        
        category = result.get("category", "unknown")
        link = result.get("link")
        response = result.get("response", "I'm here to help. What do you need?")
        
        return category, link, response
        
    except json.JSONDecodeError:
        return "unknown", None, "I'm not sure how to help with that. Please ask about: test cases, banking products (CIF/Loan/CCOD/Deposits), or Q&A application."
    except Exception as e:
        print(f"Error with LLM: {e}")
        return "unknown", None, "Sorry, there was an error processing your request. Please try again."

@app.post("/chat")
async def chat(request: ChatRequest):
    """
    Process user message with LLM and return response with link if applicable
    """
    user_message = request.message.strip()
    
    if not user_message:
        return ChatResponse(
            message="Please provide a message",
            link=None,
            category=None
        )
    
    category, link, response_msg = detect_intent_with_llm(user_message)
    
    return ChatResponse(
        message=response_msg,
        link=link,
        category=category
    )

@app.get("/health")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
